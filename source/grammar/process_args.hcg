# Grammar for processing argument variables from a CLI

# Each argument can either be a raw identifier, a string, or a labeled 
# identifier with an optional value.
#
# labeled identifiers start with either a -- or - followed by an js_identifier
# optionally followed by a = and a non spaced character sequence or string.
#
# labeled identifiers proceeded by a - are split into single characters identifiers
# with the last symbol serving as the key of any following value.

@IMPORT default-productions as def

@IGNORE Î¸ws

<> start > args

<> args > ( ( arg(*) ) f:r{ $sym1.flat().map(({key,val})=>[key, val]) } )

												f:r{  (Object.assign( Object.fromEntries( $$sym1.map( ([key, val], i)=>[key, {index:i, val: val || true}])), {__array__ : $sym1} ) ) }

<> arg > arg_initials 
	| arg_key_val
	| naked_arg

<> arg_initials > \- def::js_identifier ( \= ? val f:r{ {e:!!$$sym1, v:$sym2} } )?

												f:r{(env, $sym2.split("").flatMap((v,i,r)=>( (i==r.length-1)? ($$sym3) ? ( !!( typeof env.data[v] == "string" ? env.data[env.data[v]] :  env.data[v] ) || ($$sym3.e))? { key:v, val:  $$sym3.v } : [{key:v, val:true }, {key:$$sym3.v }]: { key:v } : { key:v } ))) }

<> arg_key_val > \-- key ( \= ? val f:r{ {e:!!$$sym1, v:$sym2} } )? 			

												f:r{ ($$sym3) ? ( !!( typeof env.data[$$sym2] == "string" ? env.data[env.data[$$sym2]] :  env.data[$$sym2] ) || $$sym3.e)? {key:$$sym2, val:$sym3.v} : [{key:$$sym2, val:true}, {key:$$sym3.v, val:true}]: {key:$sym2}}

<> naked_arg >  val g:ws?	 					f:r{ { key:$sym1 + $sym2, val:null } }


<> key > def::js_identifier

<> val > def::string
	| def::string_value g:ws? 					f:r{ $sym1  } 
